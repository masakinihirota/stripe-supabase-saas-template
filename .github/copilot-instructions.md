# Webアプリ開発プロジェクトのための全体の手順

最初に設計書をもとにタスク分解を行います。
タスク分解をしたものをタスクリストファイルに登録します。
タスク分解で分けたものを1タスクとします。
1タスクはGitHub Copilotに読み込ませるのに適切な大きさです。

[繰り返し]
1タスクを元に詳細な情報を載せたプロンプトファイルを作成します。
開発者は、プロンプトファイルに詳細な実装のための情報を補強します。
開発者とGitHub Copilotの双方が確認したプロンプトファイルを利用して機能を追加していきます。
GitHub Copilotはコードを生成します。
生成されたコードに技術的負債がないかを確認します。
実装後、ユニットテスト、結合テスト、E2Eテスト等を行います。
問題があれば、リファクタリングを行います。
ソースコードだけを見てもらってコードの批判と分析をしてもらいます。
レビューをします。

設計書の最後まで、これを繰り返します。



# Webアプリ開発のための設計書＆指示書・プロンプトファイル

最初にWebアプリの**設計書**を作っておきます。
設計書から**タスクリストファイル**やGitHub Copilotへの**指示書・プロンプトファイル**を作成します。

## 指示書の優先順位

メモリーファイル＞プロンプトファイル＞個別の指示書＞全体の指示書

## フォルダ・ファイルの種類

設計書(複数)
タスクリストファイル: タスク一覧
指示書 全体の指示書(1ファイル): プロジェクト全体で共通する指示
指示書 個別の指示書(複数): 全体の指示書ではかけなかった個別の指示
指示書 プロンプトファイル(複数): タスクの実装詳細情報
指示書 メモリーファイル(1ファイル): 実行履歴

## 振る舞い

GitHub Copilot に、以下の技術スタックに精通したエキスパートとして振る舞ってください。

* TypeScript、Node.js、Next.js (App Router)、React
* Shadcn/UI、Radix UI、Tailwind CSS
* Zustand
* Supabase、Drizzle ORM
* Zod
* Stripe
* Vitest、React Testing Library
* Storybook

## タスク管理

### タスクリストファイルの作成と更新

1.  **設計書の確認とタスク分解**:
    * 最初に設計書を確認します。
    * 設計書の場所は **design/** にあります。
    * 設計書を元に、1機能単位にタスク分解を行います。
    * タスク分解したものをタスクリストファイルに登録します。

2.  **タスクリストファイルの管理**:
    * `task-list.prompt.md` ファイルを作成、編集、更新します。
    * それぞれのタスクにタスクIDを割り当てます。
    * 現在のタスク、これから行うタスクを記録します。
    * 完了したタスクは、終了後すぐに `task-list.prompt.md` にチェックマークを付けます。
    * 開発中に発見された新しいタスクや TODO は、`task-list.prompt.md` の「作業中に発見」セクションに追加します。

### プロンプトファイルの作成と実行

1.  **プロンプトファイルの作成**:
    * タスクリストファイルから、1タスク1機能ごとにプロンプトファイルを作成します。
    * 1プロンプトファイルは1機能1タスクを守ります。
    * タスクリストファイルから1タスクを取り出した時、以下の命名規則でプロンプトファイルを作成します。
    * プロンプトファイルの命名規則

プロンプトファイルのフォーマット
`.github/prompts/[YYYYMMDD]-[タスクid]-[タスク名]-[タスクの種類].prompt.md`

例: 20240426-123-loginFeature-feat.prompt.md

feat: 機能開発（新しい機能の追加）
fix: バグ修正
test: テスト関連
doc: ドキュメント関連
refactor: リファクタリング
style: スタイル調整

2.  **プロンプトファイルの実行**:
    * 指示されたプロンプトファイルに基づいてファイル内に書いてある指示を実行します。
    * プロンプトファイルの実行前に `task-list.prompt.md` を確認します。
    * プロンプトファイルの実行時に `copilot-instructions.md` に記述されているルールに従います。
    * プロンプトファイルの実行後、「プロンプトファイル完了後の処理」の指示に従います。

### プロンプトファイル完了後の処理

1.  **タスクリストファイルの更新**:
    * 完了したタスクは、終了後すぐに `task-list.prompt.md` にマークします。
    * GitHub Copilot は `task-list.prompt.md` を更新します。
        * 例: 「`task-list.prompt.md` の〇〇が完了したのでチェックし、△△を新しいタスクとして追加してください。」

2.  **コードレビューと改善**:
    * プロジェクトの背景情報を一切見ずに、ソースコードだけを読み、ソースコードや設計を批判します。
    * すべてのdeprecatedのコードを削除します。
    * 新しい仕組みへの中間状態を作らないようにします。
    * 技術的負債を徹底的に無くします。

### 技術的負債の定義と解消

* **技術的負債の定義**:
    * コードの重複
    * 複雑すぎるコード
    * テストがないコード
    * ドキュメントがないコード
    * パフォーマンスが悪いコード
    * セキュリティ上の問題があるコード

* **技術的負債の解消方法**:
    * リファクタリング
    * テストの追加
    * ドキュメントの作成
    * パフォーマンス改善
    * セキュリティ修正

## GitHub Copilot の動作ルール

* コンテキストが不明な場合は、質問してください。
* 存在しないライブラリや関数は使用せず、既知の、検証されたライブラリのみを使用してください。
* コードやテストで参照する前に、ファイルパスやモジュール名が存在することを確認してください。
* 明示的に指示されていない限り、または `task-list.prompt.md` のタスクに含まれていない限り、既存のコードを削除または上書きしないでください。
* プロジェクトの修正や変更を行う際は、一度に 1 つのタスクに集中してください。
* 変更、修正があった場合メモリーファイル `memory.md` を更新してください。
* コード変更後は、タスクリストファイル `task-list.prompt.md` を更新してください。


### メモリーファイル

メモリーファイル `memory.md` には、

* 開発環境、使用技術
* システムの構成、技術的判断、設計パターン
* プロジェクトの目的、解決する問題、期待される挙動
* 現在作業中の内容、最近の変更点、次のステップ
* 完成済みの機能、進捗状況、残りの作業
を書いてください。

例

```memory.md
[開発環境、使用技術]

[システムの構成、技術的判断、設計パターン]

[プロジェクトの目的、解決する問題、期待される挙動]

[現在作業中の内容、最近の変更点、次のステップ]

[完成済みの機能、進捗状況、残りの作業]

```



## 使用技術スタック

### 基本事項

* 言語: TypeScript、Node.js
* フレームワーク: Next.js (App Router)、React
* UI ライブラリ: Shadcn/UI、Radix UI、Tailwind CSS
* 状態管理: Zustand
* ORM: Drizzle ORM
* バックエンド: Supabase
* スキーマ検証: Zod
* 決済: Stripe
* テスト: Vitest、React Testing Library
* UI コンポーネント管理: Storybook

### 環境変数

* 環境変数は `.env` ファイルおよび `.env.local` ファイルで管理し、Next.js の仕組みに従って安全に利用してください。

## コーディング規約

* 性能よりもシンプルさを優先してください。
* 関数型および宣言型のプログラミングパターンを推奨し、クラスの使用は極力避けてください。
* コンポーネントの配置パターンには、コンポーネントのコロケーションを考慮してください。
* コロケーションを利用したコンポーネントは、同じフォルダにビューコンポーネント、ビジネスロジックコンポーネント、フェッチコンポーネント、テストファイル、およびストーリファイルを配置してください。
* anyを使用しないでください。
* 型安全を設定してください。
* 1 ファイルあたりの行数は 500 行以内にしてください。ファイルがこの制限に近づいたら、モジュールやヘルパーファイルに分割してリファクタリングしてください。
* 機能または責任ごとに、明確に分離されたモジュールにコードを整理してください。
* 指示は具体的に記述し、曖昧な部分があれば指摘してください。
* 互換性は残さないでください、全て消してください。



### コードのコメント

* コメント形式: JSDocを使った明確なコンテキストを書いてください。
* コードを修正したらコメントも適切なものにしてください。
* 不要なコメントは削除してください。
* 食い違いのあるコメントは修正してください。


## テストに関する指示

* 関数はユニットテストを書いてください。
* 全ての新しい機能にユニットテストを記述してください。
* Vitest を使用してユニットテストを記述してください。
* React Testing Library を使用してコンポーネントのテストを記述してください。
* テストは `describe` でグループ化し、`it` でテストケースを記述してください。
* テストケースは日本語で記述してください。
* ロジックを変更した場合は、既存のユニットテストを更新する必要があるか確認し、必要に応じて更新してください。
* テストは、コンポーネントと同じフォルダ内に配置してください (コロケーション)。
* テストには、少なくとも次のものを含めてください。
    * 予想される使用に対するテスト
    * 1 つのエッジケースのテスト
    * 1 つの失敗ケースのテスト

## UI に関する指示

* UI はシンプルで直感的なデザインを心がけてください。
* モバイルフレンドリーなレスポンシブデザインを考慮してください。

## セキュリティ

* `.env*` ファイルは git で管理しないでください。

## ドキュメント

* `README.md` には、使い方や説明などを記述してください。
* 変更内容は `README.md` に反映させてください。


### テストのベストプラクティス

* テストは、コンポーネントと同じフォルダ内に作成してください (コロケーション)。
* DB や GitHub Copilot のようなサービスへの呼び出しは、常に「モック」を使用してください。
* 各関数について、少なくとも 1 つの成功シナリオ、1 つの意図的な失敗 (適切なエラー処理を保証するため)、および 1 つのエッジケースをテストしてください。

## MCP (Model Context Protocol) の設定

* MCP の設定は `.vscode\mcp.json` にあります。
* 現在の MCP の設定: Supabase
